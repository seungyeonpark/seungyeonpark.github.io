---
title: "데이터 중심 애플리케이션 설계 (1)"
excerpt: "Designing Data Intensive Applications - Martin Kleppmann"

categories:
  - 기술서적
tags:
  - [데이터 중심 애플리케이션 설계]

permalink: /techbook/designing-data-intensive-applications-1

toc: true
toc_sticky: true

date: 2024-03-16
last_modified_at: 2024-03-16
---

> **_"오늘날 많은 애플리케이션은 계산 중심(compute-intensive)과는 다르게 데이터 중심(data-intensive)적이다.
> 이러한 애플리케이션의 경우 CPU 성능은 애플리케이션을 제한하는 요소가 아니며, 
> 더 큰 문제는 보통 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도다."_**

이 책은 데이터 시스템의 원칙(principle)과 실용성(practicality), 그리고 이를 활용한 데이터 중심 애플리케이션을 개발하는 방법 전반에 대해 다룬다.
데이터 중심 애플리케이션이 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소(standard building block)은 다음과 같다

|building block| description                                           |
|---|-------------------------------------------------------|
|Database| 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터 영속 저장 |
|Cache|읽기 속도 향상을 위해 값비싼 수행 결과 기억|
|Search Index|사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공|
|Stream Processing|비동기 처리를 위해 다른 프로세스로 메시지 보내기|
|Batch Processing|주기적으로 대량의 누적된 데이터를 분석|

- - -

# 01장. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
1장에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.
- 신뢰성(Reliability)
  - 하드웨어나 소프트웨어 결함, 심지어 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야 한다.
- 확장성(Scalability)
  - 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.
- 유지보수성(Maintainability)
  - 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(현재 작업을 유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링과 운영)할 것이기 땜누에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.

<br>

## 1. 신뢰성
결함을 예측하고 대처할 수 있는 내결함성(fault-tolerant) 또는 탄력성(resilient)이 신뢰성 결정의 주요 요소이다.
이때 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.

일반적으로 결함 예방을 넘어 내결함성을 갖기를 선호하지만 예방책이 해결책보다 좋은 경우(예를 들어 해결책이 없기 때문에)가 있다. 바로 보안 문제다. 
예를 들어 공격자가 시스템을 손상시키고 민감 데이터에 대한 접근 권한을 얻는다면 이를 되돌릴 수 없다. 
이 책은 해결책이 있는 결함 유형에 대해 다룬다.

### 1-1. 하드웨어 결함
> _하드디스크의 평균 장애 시간(mean time to failure, MTTF)은 약 10~50년으로 보고됐다. 따라서 10,000의 디스크로 구성된 저장 클러스터는 평균적으로 하루에 한 개의 디스크가 죽는다고 예상해야 한다._

- 단일 장비 + 하드웨어 구성 요소 중복
  - 디스크는 RAID 구성
  - 서버는 이중 전원 디바이스, 핫 스왑(hot-swap) 가능 CPU
  - 데이터센터는 건전지와 예비 전원용 디젤 발전기 
- 다중 장비 + 소프트웨어 내결함성 기술
  - 데이터 양과 애플리케이션의 계산 요구가 늘어나며 더 많은 애플리케이션이 많은 수의 장비를 사용
  - AWS와 같은 클라우드 플랫폼은 가상 장비 인스턴스가 별도의 경고 없이 사용할 수 없게 되는 상황이 일반적이다. 이런 플랫폼은 단일 장비 신뢰성보다 유연성(flexibility)과 탄력성(elasticity)을 우선적으로 처리하게끔 설계되었기 때문이다.
  - 따라서 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비 손실을 견딜 수 있는 시스템으로 옮겨가고 있다.

<br>

### 1-2. 소프트웨어 오류
- 시스템 내 체계적 오류(systematic error)는 예상하기 더 어렵고 노드 간 상관관계 때문에 하드웨어 결함보다 오히려 오류를 더욱 많이 유발하는 경향이 있다.
- systematic error 예시
  - 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그. 예를 들어 리눅스 커널의 버그로 인해 많은 애플리케이션이 일제히 멈춰버린 2012년 6월 30일 윤초
  - CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스
  - 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
  - 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례로 더 많은 결함이 발생하는 연쇄 장애(cascading failure)
- systematic error는 신속한 해결책이 없다. 시스템의 가정과 상호작용에 대한 주의, 빈틈없는 테스트, 프로세스 격리(process isolation), 죽은 프로세스의 재시작 허용, 프로덕션 환경에서 시스템 동작의 측정, 모니터링, 분석하기와 같은 작은 일들이 문제 해결에 도움을 줄 수 있다.
- 시스템이 뭔가를 보장하길 기대한다면(예를 들어 메시지 큐에 수신된 메시지 수와 송신된 메시지 수가 같다) 수행 중에 이를 지속적으로 확인해 차이가 생기는 경우 경고를 발생시킬 수 있다.

<br>

### 1-3. 인적 오류
> _"대규모 인터넷 서비스에 대한 한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인인 반면 하드웨어(서버나 네트워크) 결함은 중단 원인의 10~25% 정도에 그친다."_

- 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라. 예를 들어 잘 설계된 추상화, API, 관리 인터페이스를 사용하면 "옳은 일"은 쉽게 하고, "잘못된 일"은 막을 수 있다.
- 실제 데이터를 사용해 안전하게 살펴보고 실험할 수 있지만 실제 사용자에게는 영향이 없는 비 프로덕션 샌드박스(sandbox)를 제공하라
- 단위 테스트부터 전체 시스템 통합 테스트와 수동 체스트까지 모든 수준에서 철저하게 테스트하라.
- 설정 변경 내역을 빠르게 롤백하고 새로운 코드를 서서히 롤아웃하게 만들고 이전 계산이 잘못된 경우를 대비해 데이터 재계산 도구를 제공하라.
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라.

<br>
<br>

## 2. 확장성
확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?"와 "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?" 같은 질문을 고려한다는 의미다.

### 2-1. 부하 기술하기
- 부하 매개변수(load parameter)
  - 웹 서버의 초당 요청 수
  - 데이터베이스의 읽기 대 쓰기 비율
  - 대화방의 동시 활성 사용자(active user)
  - 캐시 적중률

<br>

### 2-2. 성능 기술하기
#### a. 성능 지표

|성능 지표|설명|
|---|---|
|처리량(throughput)|초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간|
|응답 시간(response time)| 클라이언트가 요청을 보내고 응답을 받는 사이의 시간. 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함|
|지연 시간(latency)|요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간|
|꼬리 지연 시간(tail latency)|큐 대기 지연(queueing delay) 현상과 같이 소수의 느린 요청 처리로 후속 요청 처리가 지체되는 선두 차단(head-of-line blocking) 현상. 이런 문제 때문에 클라이언트 쪽 응답 시간 측정이 중요|

  - 꼬리 지연 증폭(tail latency amplification)
    - 사용자 요청이 여러 번 백엔드를 호출하는 경우 최종 사용자 요청은 가장 느린 호출이 완료되길 기다려야 한다.
    - 작은 비율의 백엔드 호출만 느려져도 최종 사용자 요청 중 많은 비율의 응답 시간이 느려지는 효과를 꼬리 지연 증폭(tail latency amplification)이라 한다.

#### b. 응답 시간
  - 응답 시간은 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야 한다.
    - 클라이언트가 몇 번이고 반복해서 동일한 요청을 하더라도 매번 응답 시간이 다르기 때문이다.
    - 백그라운드 프로세스 컨텍스트 스위치, 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 휴지(garbage collection pause), 디스크웨서 읽기를 강제하는 페이지 폴트(page fault), 서버 랙의 기계적인 진동 등 여러 원인으로 추가 지연이 생길 수 있다.
  - 사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 중앙값이 좋은 지표다.
  - 특이 값이 얼마나 좋지 않은지 알아보려면 상위 백분위를 살펴본다. 이때 사용하는 백분위는 95분위, 99분위, 99.9분위가 일반적이다.

> _"보통 응답 시간이 가장 느린 요청을 경험한 고객들은 많은 구매를 해서 고객 중에서 계정에 가장 많은 데이터를 갖고 있어서다.(즉, 이들은 가장 소중한 고객이다)."_

> _"아마존은 응답 시간이 100밀리초 증가하면 판매량이 1% 줄어들고 1초가 느려지면 고객의 만족도 지표는 16% 줄어드는 현상을 관찰했다."_

<br>

### 2-3. 부하 대응 접근 방식
- 아키텍처를 결정하는 요소는 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터 복잡도, 응답 시간 요구사항, 접근 패턴 등이 있다.
- 탄력적 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다.
- 다수의 장비에 상태 비저장(stateless) 서비스를 배포하는 일은 상당히 간단한다. 하지만 단일 노드에 상태 유지(stateful) 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가로 발생한다.
- 스타트업 초기 단계나 검증되지 않은 제품의 경우에 미래를 가정한 부하에 대비해 확장하기보다는 빠르게 반복해서 제품 기능을 개선하는 작업이 더 중요하다.

<br>
<br>

## 3. 유지보수성
### 3-1. 운용성(operability)
- "좋은 운영은 불완전한 소프트웨어의 제약을 피하는 대안이 될 수 있다. 하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 앖다."
- 운영 중 일부 측면은 자동화할 수 있고 또 자동화해야 한다. 그러나 자동화를 처음 설정하고 제대로 동작하는지 확인하는 일은 여전히 사람의 몫이다.

<br>

### 3-2. 단순성(simplicity)
- 복잡도는 다양한 증상으로 나타난다. 상태 공간의 급증, 모듈 간 강한 커플링(tight coupling), 복잡한 의존성, 일관성 없는 명명(naming)과 용어, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례(special-casing)
- 시스템을 단순하게 만드는 일이 반드시 기능을 줄인다는 의미는 아니다. 우발적 복잡도(accidental complexity)를 줄인다는 뜻일 수도 있다. 우발적 복잡도란 사용자에게 보이는 문제에 내재하고 있지 않고 구현에서만 발생하는 문제이다.
- 우발적 복잡도를 제거하기 위한 최상의 도구는 추상화다.

<br>

### 3-3. 발전성(evolvability)
- 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 한다.
- 유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)
