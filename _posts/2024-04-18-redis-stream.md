---
title: "Redis stream 활용"
excerpt: "Redis에서 stream 데이터를 처리하는 방법에 대해 알아보자"

categories:
  - Redis
tags:
  - [redis]

permalink: /redis/redis-stream

toc: true
toc_sticky: true

date: 2024-04-19
last_modified_at: 2024-04-19
---

## 레디스의 Stream과 아파치 카프카
- Stream은 레디스 5.0에서 새로 추가된 자료 구조로 대용량, 대규모의 메시징 데이터를 빠르게 처리할 수 있도록 설계됐다
- 일반적으로 로그가 파일의 내용을 업데이트하거나 지우지 않고 쌓기만 하는 것처럼 stream 또한 데이터를 계속해서 추가하는 방식으로 저장되는(append-only) 자료 구조다
- stream의 두 가지 활용
  - 백엔드 개발자는 stream을 대량의 데이터를 효율적으로 처리하는 플랫폼으로 활용
  - 데이터 엔지니어는 stream을 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 시스템으로 활용

## 데이터의 저장
### 메시지의 저장과 식별
- 레디스에서는 하나의 stream 자료 구조가 하나의 stream을 의미한다
- 각 자료 구조가 하나의 키에 연결되는 것과 마찬가지로 stream 또한 하나의 키에 연결된 자료 구조다
- 레디스 stream에서 각 메시지는 시간과 관련된 유니크한 ID를 가진다
  ```
  <millisecondsTime>-<sequenceNumber>
  ```
  - ID는 위와 같이 밀리세컨드 파트와 시퀀스 파트로 나뉜다
  - 밀리세컨드 파트
    - 실제 stream에 아이템이 저정될 시점의 레디스 노드 로컬 시간
  - 시퀀스 파트
    - 동일 밀리세컨드 시간에 여러 아이템이 저장될 수 있으므로, 같은 밀리세컨드에 저장된 데이터의 순서를 의미한다
    - 시퀀스 번호는 64bit
  - ID 값이 곧 시간을 의미하기 때문에 시간을 이용해 특정 데이터를 검색할 수 있다

### 스트림 생성과 데이터 입력
- 레디스에서는 따로 stream을 생성하는 과정은 필요하지 않으며, XADD 커맨드를 이용해 새로운 이름의 stream에 데이터를 저장하면 데이터의 저장과 동시에 stream 자료 구조가 생성된다
  ```
  XADD Email * subject "first" body "hello?"
  ```
  - 위 커맨드를 실행하면 Email이라는 이름의 stream이 생성된다
  - 만약 기존에 같은 이름의 키가 존재했다면 이 커맨드는 기존 stream에 새로운 메시지를 추가하며, 존재하지 않았을 때는 Email이라는 이름의 키를 가진 새로운 stream 자료 구조를 생성한다
  - \* 필드는 저장되는 데이터의 ID를 의미하며, 이 값을 \*로 입력할 경우 레디스에서 자동 생성되는 타임스탬프 ID를 사용하겠다는 것을 의미
  - XADD 커맨드를 사용했을 때 반환되는 값이 바로 저장되는 데이터의 ID
  - 메시지는 key-value 쌍으로 저장되며, 위 커맨드에서 subject하는 키에는 first 값이, body 키에는 hello? 값이 저장된다
- 자동으로 생성되는 ID가 아니라 서비스에서 기존에 사용하던 ID를 이용해 메시지를 구분하는 경우에는 ID 필드에 \*가 아니라 직접 ID 값을 지정하면 된다
- 직접 지정하는 경우 이후 저장되는 stream의 ID는 이전에 저장됐던 ID 값보다 작은 값으로 지정할 수 없다

## 데이터 조회
- 레디스 strean에서는 데이터를 두 가지 방식으로 읽을 수 있다
- 첫 번째는 카프카에서처럼 실시간으로 처리되는 데이터를 리스닝
- 두 번째는 ID를 이용해 필요한 데이터를 검색하는 방식

### 실시간 리스닝
```
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
```

### 특정 데이터 조회

## 소비자와 소비자 그룹

## ACK와 보류 리스트


## 메시지의 재할당
메시지의 자동 재할당
메시지의 수동 재할당

## stream 상태 확인
