---
title: "Docker 파일 시스템"
excerpt: "Docker 파일 시스템에 대해 알아보자"

categories:
  - Docker
tags:
  - [docker]

permalink: /docker/docker-file-system

toc: true
toc_sticky: true

date: 2024-04-26
last_modified_at: 2024-04-26
---

## 컨테이너 파일 시스템
- 모든 컨테이너는 독립된 파일 시스템을 갖는다. 같은 이미지에서 실행한 여러 개의 컨테이너는 처음에는 디스크의 내용이 모두 같지만, 그중 한 컨테이너에서 애플리케이션이 파일을 수정해도 다른 컨테이너나 이미지는 영향을 받지 않는다. 
- 컨테이너의 파일 시스템은 단일 디스트(리눅스 컨테이너는 /dev/sda1, 윈도우 컨테이너는 C:\)다. 그러나 이 디스크는 도커가 여러 출처로부터 합쳐 만들고 컨테이너에 전달한 가상 파일 시스템이다. 이 출처는 기본적으로 이미지 레이어와 컨테이너의 기록 가능 레이어로 구성되는데, 이미지 레이어는 모든 컨테이너가 공유하지만 기록 기능 레이어는 컨테이너마다 다르다.
- 모든 컨테이너가 공유하는 이미지 레이어는 읽기 전용이고, 각 컨테이너가 따로 갖는 기록 기능 레이어는 컨테이너와 같은 생애주기를 가진다.
- 이미지 레이어는 이미지를 내려받은 순간부터 삭제할 때까지 로컬 컴퓨터의 이미지 레이어에 존재한다. 그러나 컨테이너의 쓰기 가능 레이어는 컨테이너를 실행할 때 생성되며 컨테이너를 삭제할 때 함께 삭제된다.
- 컨테이너를 종료하는 것만으로는 컨테이너가 삭제되지 않는다. 그래서 종료된 컨테이너의 데이터도 그대로 남아 있는 것이다.
- 기록 가능 레이어를 새 파일 만드는 데만 사용하는 것은 아니다. 기존 이미지 레이어에 있는 파일을 수정할 수도 있다.
- 도커는 기록 중 복사(copy-on-write)라는 방법을 사용해 읽기 전용 레이어의 파일을 수정할 수 있다.
- 컨테이너에서 이미지 레이어에 포함된 파일을 수정하려 하면, 먼저 도커가 이 파일을 쓰기 가능 레이어로 복사해 온 다음 쓰기 가능 레이어에서 파일을 수정한다.
- 컨테이너 속 파일을 수정하면 컨테이너의 동작에 영향을 미친다. 그러나 이미지를 공유하는 다른 컨테이너나 이미지는 영향을 받지 않는다. 수정된 파일은 해당 컨테이너의 기록 가능 레이어에만 존재하기 때문이다. 새로운 컨테이너는 이미지로부터 받은 최초의 내용을 담은 파일 시스템을 가진다.
- 컨테이너 파일 시스템은 컨테이너와 같은 생애주기를 갖는다. 컨테이너가 삭제되면 이 컨테이너의 기록 가능 레이어와 여기서 수정된 데이터도 함께 삭제된다. 
- 실무에서는 새 이미지를 빌드하고 오래된 컨테이너를 삭제한 다음 새 이미지에서 실행한 컨테이너로 대체하는 방법으로 애플리케이션을 업데이트한다.
- 이 과정에서 기존 컨테이너에 있는 수정된 데이터는 모두 손실된다. 새 컨테이너는 이미지에서 받은 파일만 갖고 있기 때문이다.
- 도커 볼륨(Docker volume)과 마운트(mount)는 컨테이너와는 별개의 생애주기를 갖는다. 그래서 컨테이너가 대체돼도 지속돼야 할 데이터를 저장할 수 있다.

## 도커 볼륨을 사용하는 컨테이너 실행
- 도커 볼륨은 도커에서 스토리지를 다루는 단위다.
- 볼륨은 컨테이너와 독립적으로 존재하며 별도의 생애주기를 갖지만, 컨테이너에 연결할 수 있다. 
- 퍼시스턴시가 필요한 유상태 애플리케이션을 컨테이너로 실행하려면 볼륨을 사용해야 한다. 
- 볼륨을 생성해 애플리케이션 컨테이너에 연결하면 컨테이너 파일 시스템의 한 디렉터리가 된다. 나중에 애플리케이션을 업데이트하더라도 새로운 컨테이너에 다시 볼륨을 연결하면 데이터가 그대로 유지된다.
- 컨테이너에서 볼륨을 사용하는 방법
  1. 수동으로 직접 볼륨을 생성해 컨테이너에 연결하는 방법
  2. Dockerfile 스크립트에서 VOLUME 인스트럭션을 사용하는 방법
     - VOLUME <target-directory> 형식의 인스트럭션을 사용해 이미지를 만들고 컨테이너를 실행하면 자동으로 볼륨을 생성한다.
- 컨테이너 간 볼륨 공유
```
docker container run -d --name t3 --volumes-from todo1 diamol/ch06-todo-list
```
- 애플리케이션 컨테이너는 자신만이 접근할 수 있는 파일을 필요로 한다. 이런 파일을 다른 컨테이너가 동시에 접근하게 허용하면 애플리케이션이 비정상적으로 동작할 수 있다.
- 볼륨은 컨테이너 간 파일 공유보다는 컨테이너 업데이트 간 상태를 보존하기 위한 용도로 사용해야 하며, 이미지에서 정의하는 것보다는 명시적으로 관리하는 편이 더 낫다. 볼륨에 이름을 붙여 생성하고 업데이트 시 다른 컨테이너로 옮겨 연결하면 된다.
- 볼륨 생성
```
docker volume create todo-list
```
- 새 컨테이너 실행 시 컨테이너의 파일 시스템 경로에 지정한 볼륨을 마운트
```
docker container run -d -p 8011:80 -v todo-list:/data --name todo-v1 diamol/ch06-todo-list
```
- Dockerfile 스크립트의 VOLUME 인스트럭션과 docker container 명령의 --volume 플래그는 별개 기능이다.
- VOLUME 인스트럭션을 사용해 빌드된 이미지로 docker container run 명령에서 볼륨을 지정하지 않으면 항상 새로운 볼륨을 함께 생성한다. 이 볼륨은 무작위로 만들어진 식별자를 가지므로, 컨테이너를 삭제한 후 볼륨을 재사용하려면 이 식별자를 미리 기억해야 한다.
- 반면 --volume 플래그는 이미지에 볼륨이 정의돼 있든 말든 지정된 볼륨을 컨테이너에 마운트한다. 이미지에 볼륨이 정의돼 있더라도 이 정의가 무시되므로 새로운 볼륨이 생성되지 않는다.
- 이미지에 볼륨이 정의돼 있지 않아도 똑같은 결과를 얻는다. 이미지를 만드는 입장에서는 안전장치 삼아 VOLUME 인스트럭션을 이미지 정의에 포함시켜 두는 것이 좋다. 그러면 사용자가 볼륨을 지정하지 않더라도 데이터를 유실할 일이 없다. 하지만 사용자 관점에서는 이미지의 기본 볼륨 설정에 의존하지 않고 별도로 이름을 붙여 만든 볼륨을 사용하는 것이 좋다.

## 파일 시스템 마운트를 사용하는 컨테이너 실행
- 볼륨의 장점은 컨테이너와 스토리지의 생애주기를 분리하면서도 도커를 사용하는 방식 그대로 스토리지를 다룰 수 있다는 점이다. 볼륨 역시 호스트 컴퓨터상에 존재하지만 컨테이너와는 분리돼 있기 때문이다.
- 바인드 마운트(bind mount)의 경우 호스트의 스토리지를 컨테이너에 좀 더 직접적으로 연결할 수 있는 수단이다.
- 바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 만든다. 
- 바인드 마운트도 볼륨과 마찬가지로 컨테이너의 입장에서는 그냥 평범한 디렉터리에 불과하다. 그러나 도커를 사용하는 입장에서는 컨테이너가 호스트 파일에 직접 접근할 수 있고 그 반대도 가능해즤므로 좀 더 흥미로운 일을 할 수 있다.

## 파일 시스템 마운트의 한계